Перегрузка функций в С++ это мощный концепт, позволяющий существенно облегчить управление уникальными именами функций.

Рассмотрим следующую функцию:

```cpp
int Add(int x, int y) {
   return x + y;
}
```

Эта тривиальная функция складывает два целых числа и возвращает результат тоже в виде целого числа. Однако что, если нам понадобится функция, которая может складывать два числа с плавающей запятой? Функция Add() не подходит для этого, так как все аргументы с плавающей запятой будут преобразованы в целые числа, что приведет к потере дробных частей аргументов с плавающей запятой.

Один из способов решить эту проблему - определить несколько функций с немного разными именами:

```cpp
int AddInteger(int x, int y) {
   return x + y;
}

double AddDouble(double x, double y) {
 return x + y;
}
```

Однако, чтобы достичь наилучшего результата, это потребует определения единых правил именования для аналогичных функций с разными типами параметров, а также запоминания названий всех различных вариантов функций и правильного вызова нужной из них.

Что произойдет, когда нам понадобится функция, которая складывает три целых числа вместо двух? Управление уникальными именами для каждой функции быстро станет утомительным.

## Знакомство с перегрузкой функций.

К счастью, в C++ есть элегантное решение для таких случаев. **Перегрузка функций** позволяет создавать несколько функций с одним и тем же именем, при условии, что все эти функции имеют разные параметры (или функции могут различаться иным образом). Все функции с одинаковыми именами (в одной и той же области видимости) называются **перегруженными функциями**.

Чтобы перегрузить нашу функцию Add(), мы можем просто определить другую функцию Add(), которая принимает параметры типа double:

 ```cpp
 int add(int x, int y) {
   return x + y;
}

double add(double x, double y) {
   return x + y;
}
```

Показанный выше код будет успешно компилироваться. Хотя можно ожидать, что эти функции приведут к конфликту имен, на самом деле это не так. Поскольку типы параметров у этих функций различаются, компилятор может различать их и рассматривать как отдельные функции, которые просто имеют общее имя.

## Разрешение перегрузки.

Когда происходит вызов функции, которая была перегружена, компилятор, исходя из аргументов, используемых в вызове, пытается сопоставить этот вызов с соответствующей перегрузкой. Это называется **разрешением перегрузки**.

Вот простой пример, демонстрирующий это:

```cpp
#include <iostream>

int Add(int x, int y) {
   return x + y;
}

double Add(double x, double y) {
   return x + y;
}

int main() {
   std::cout << Add(1, 2);     // вызывает Add(int, int)
   std::cout << '\n';
   std::cout << Add(1.2, 3.4); // вызывает Add(double, double)

   return 0;
}
```
Показанный выше код компилируется и дает следующий результат:

<pre class='hexlet-basics-output'>
 3
 4.6
</pre>

Когда мы передаем целочисленные аргументы в вызове Add(1, 2), компилятор определяет, что мы пытаемся вызвать функцию Add(int, int). А когда мы передаем аргументы с плавающей запятой в вызове Add(1.2, 3.4), компилятор определяет, что мы пытаемся вызвать функцию Add(double, double).

Перегрузка функций предоставляет отличный способ снизить сложность программы за счет уменьшения количества имен функций, которые нужно запомнить. Ее можно и нужно использовать.
