В предыдущем уроке мы познакомились с перегрузкой функций, которая позволяет нам создавать несколько функций с одинаковыми именами, если все эти функции имеют разные параметры.

В этом уроке мы поговорим о том, как различаются перегруженные функции. Перегруженные функции, которые не различаются должным образом, приведут к тому, что компилятор выдаст ошибку компиляции.

Самый простой способ дифференцировать перегрузку функций – убедиться, что каждая перегруженная функция имеет отличающийся набор параметров.

## Перегрузка по количеству параметров

Перегруженные функции различаются до тех пор, пока каждая перегруженная функция имеет разное количество параметров. Например:

```cpp
#include <iostream>
#include <string>

std::string GetUserData (std::string email) {
  std::string full_name = email.substr(0, email.find("@"));
  return "User full name: " + full_name + "\n" + "User email: " + email;
}

std::string GetUserData (std::string first_name, std::string last_name, std::string email) {
  std::string full_name = first_name + " " + last_name;
  return "User full name: " + full_name + "\n" + "User email: " + email;
}

int main() {
  std::cout << GetUserData ("John", "Doe", "john@gmail.com") << std::endl;
  std::cout << GetUserData ("john@gmail.com");
}
```

Результат работы программы:

```text
User full name: John Doe
User email: john@gmail.com
User full name: john
User email: john@gmail.com
```

Компилятор может легко сказать, что вызов функции с одним параметром `std::string` должен идти на `GetUserData(std::string)`, а вызов функции с тремя параметрами `std::string` должен идти на `GetUserData(std::string, std::string, std::string)`.

Обратите внимание от количества параметров может меняться и поведение функции, из примера видно, что если пользователь не ввел имя и фамилию, мы попытаем получить его полное имя из почтового адреса.

## Перегрузка по типу параметров

Функции также можно различать, если различаются наборы типов параметров каждой перегруженной функции. Например, различаются все следующие перегрузки:

```cpp
int Add(int x, int y);          // целочисленная версия
double Add(double x, double y); // версия с плавающей запятой
double Add(int x, double y);    // смешанная версия
double Add(double x, int y);    // смешанная версия
```

Поскольку псевдонимы типов (или определения `typedef`) не являются отдельными типами, перегруженные функции, использующие псевдонимы типов, не отличаются от перегрузок, использующих исходные типы. Например, все следующие перегрузки не различаются (и приведут к ошибке компиляции):

```cpp
typedef int height_t; // typedef
using age_t = int;    // псевдоним типа

void Print(int value);
void Print(age_t value);    // не отличается от print(int)
void Print(height_t value); // не отличается от print(int)
```

Для параметров, передаваемых по значению, квалификатор `const` также не учитывается. Поэтому следующие функции не считаются разными:

```cpp
void Print(int);
void Print(const int); // не отличается от print(int)
```

Это код также вызовет ошибку компиляции.

Тип возвращаемого значения функции не учитывается при различении перегруженных функций.

Рассмотрим случай, когда вы хотите написать функцию, возвращающую случайное число, но вам нужна одна версия, которая вернет `int`, и другая версия, которая вернет `double`. У вас может возникнуть соблазн сделать так:

```cpp
int GetRandomValue();
double GetRandomValue();
```

При компиляции такой программы возникнет ошибка и это логично, компилятор видит вызов функции `GetRandomValue()`, как понять какую функцию вызывать?

Выход из этой ситуации дать функциям разные имена.

В этом уроке мы узнали, что функции можно перегружать по типу передаваемых параметров и по количеству передаваемых параметров.
