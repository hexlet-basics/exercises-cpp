Представьте, что мы пишем программу, которая складывает два числа и выводит результат на экран два или даже пять раз. Можно решить задачу в лоб и написать следующее:

```cpp
int main() {
  std::cout << 2 + 3;
  std::cout << 2 + 3;
}
```

Но тут возникает проблема, что если результат сложения этих двух чисел нам понадобится где-то в программе или мы захотим поменять значение одного из слагаемых?

Нам придется найти все места в программе и выполнить необходимую замену. Но можно сделать это более изящно. Достаточно определить три переменные, в которых мы будем хранить значение чисел и результат их сложения. Давайте перепишем код с учетом наших новых знаний:

```cpp
int main() {
  int num_one = 2;
  int num_two = 3;
  int result = num_one + num_two;
  std::cout << result;
  return 0;
}
```

Разберем подробнее что тут происходит. Когда мы определяем переменную, в начале указываем ключевое слово, которое обозначает тип данных.

В данном случае у нас тип int или integer, то есть целое число. После типа идет имя переменной, оператор присваивания и значение которое будет хранится в переменной.

Стоит учитывать, С++ - это регистрозависимый язык и переменные int num и int Num - это две разные переменные. Кроме того, в качестве имени переменной нельзя использовать ключевые слова языка C++.

Можно определить переменную, не присваивая ей значение:

```cpp
int num;
```

Но так делать не стоит, потому что, если вы ее забудете проинициализировать, компилятор ей присвоит значение по умолчанию. Какое? Тут уже зависит от компилятора и места определения переменной.

В примере ниже использовался компилятор clang:

```cpp
int num_out;

int main() {
  int num_in;
  std::cout << "The num_out = " << num_out << std::endl;
  std::cout << "The num_in = " << num_in << std::endl;
}
```

Компилятор присвоил переменной значение 0.

<pre class='hexlet-basics-output'>
  The num_out = 0
  The num_in = 0
</pre>

Хорошей практикой считается определять переменную ближе к тому месту в коде где она будет использоваться и инициализировать сразу нейтральным значением.

Например, если это счетчик цикла, то 0, если в переменную будет собираться строка, то пустой строкой.

```cpp
int main() {
  string acc = "";
  acc = acc + "Hello, ";
  acc = acc + "World!";
  std::cout << acc;
}
```

<pre class='hexlet-basics-output'>
  Hello, World!
</pre>

C++ поддерживает три основных способа инициализации переменных. Во-первых, мы можем выполнить копирующую инициализацию, используя знак равенства:

```cpp
int age = 18; // копирующая инициализация значения 18 в переменную age
```

Подобно копирующему присваиванию, этот код копирует значение с правой стороны знака равно в переменную, создаваемую с левой стороны. Во-вторых, мы можем выполнить прямую инициализацию с помощью скобок:

```cpp
int age(18); // прямая инициализация значения 18 в переменную age
```

Для простых типов данных копирующая и прямая инициализации, по сути, одинаковы. Различия между копирующей инициализацией и прямой инициализацией мы разберем далее в курсе.

И третий тип инициализации - списковая. Списковая инициализация - это более унифицированный механизм инициализации, подходит как для простых типов, так и для составных, которые мы будем рассматривать дальше по курсу.

Инициализация списком бывает двух форм:

```cpp
int width { 5 };     // прямая инициализация списком значения 5 в переменную width (предпочтительно)
int height = { 6 };
```

Эти две формы функционируют почти одинаково, но обычно предпочтительнее прямая форма.
