Целые числа представляют собой бесконечное множество, и в конечном объеме памяти компьютера нельзя представить их все. Таким образом язык может представить только подмножество целых чисел. Отсюда следует определение типа, тип данных - это возможное множество значений.

Разнообразные целочисленные типы в С++ отличаются друг от друга объемом памяти, выделяемым для хранения целого значения. Чем больше объем памяти, тем шире диапазон предоставляемых целочисленных значений.

В С++ базовыми целочисленными типами, в порядке увелечения ширины, являются: `char`, `short`, `int`, `long` и `long long`. Каждый из этих типов имеет версии со знаком и без знака. Таким образом, на выбор предоставляется десять целочисленных типов. Давайте познакомимся с ними поближе:

* `short` - имеет ширину не менее 16 бит и хранит диапазон чисел от - 32768 до 32767
* `int` - имеет гарантированную ширину, как минимум такую же как `short` и диапазон чисел от -2 147 483 648 до 2 147 483 647
* `long` - имеет ширину не менее 32 бит и хранит диапазон чисел от -2 147 483 648 до 2 147 483 647
* `long long` -  имеет ширину не менее 64 бит и хранит диапазон чисел от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807

Посмотреть ширину типа в вашей системе можно с помощью оператора `sizeof()`, а диапазоны с помощью символических констант, подключив заголовочный файл стандартной библиотеки `climits`.

```cpp
#include <iostream>
#include <climits>

int main() {
  std::cout << "Integer range: from"
          << INT_MIN << " to " << INT_MAX << std::endl;
  std::cout << "Int type: " << sizeof(int) << " byte" << std::endl;
}
```

```text
  Integer range: from-2147483648 to 2147483647
  Int type: 4 byte
```


Стоит сказать, что минимальную ширину типа гарантирует язык, а максимальная зависит от архитектуры процессора.

Каждый из вышеприведённых типов может быть беззнаковым, то есть хранить только неотрицательные числа. За счет этого можно увеличить значение, которое может хранить переменная. Например, если `short` представляет диапазон от -32 768 до 32 767, то `unsigned short` от 0 до 65 532:

```cpp
#include <iostream>
#include <climits>

int main() {
  std::cout << "Int max: "
            << UINT_MAX << std::endl;
  std::cout << "Int type: " << sizeof(unsigned int) << " byte" << std::endl;
}
```

```text
  Int max: 4294967295
  Int type: 4 byte
```

Видно, что верхняя граница увеличилась в два раза, нижняя будет смещена к нулю, но на количестве выделенной памяти это не сказалось. Такое поведение связано с тем, что для хранения отрицательных чисел используется дополнительный бит.

Что будет если в беззнаковую переменную сохранить отрицательное число или выйти за пределы диапазона знаковой переменной:

```cpp
#include <iostream>
#include <climits>

#define ZERO 0 // определим символьную константу со значением 0

int main() {
  int int_number { INT_MAX }; // 2147483647
  unsigned u_int_number { ZERO }; // 0

  std::cout << "new value int_number: "
            << int_number + 1 << std::endl;
  std::cout << "new value u_int_number: "
            << u_int_number - 1 << std::endl;
}
```

```text
  new value int_number: -2147483648
  new value u_int_number: 4294967295
```

Произошла потеря значимости, то есть в обоих случаях мы получили числа другой границы диапазона и компилятор на это не указал. За этим надо следить особенно если вы работаете с большими числами.

Из всего вышесказанного возникает вопрос: Зачем такой богатый набор типов данных? Допустим, что вы пишете программу для контроллера микроволновой печи и вам известно, что данные которыми будет оперировать программа - это положительные числа, значение которых не превышает 32 000. Естественно ваш выбор падет на `unsigned short` и если у вас большой массив данных, можно существенно сэкономить память.

В остальных случаях, тип `int` имеет наиболее естественный размер целого числа для целевого компьютера. Под естественным размером подразумевается целочисленная форма, которую компьютер может обработать наиболее эффективным образом.
